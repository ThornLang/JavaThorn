import { floor } from "math";

@immut DEFAULT_SEED = 12345;
global_random_state = DEFAULT_SEED;

@immut LCG_MULTIPLIER = 1103515245;
@immut LCG_INCREMENT = 12345;
@immut LCG_MODULUS = 2147483648;

export $ random() {
    global_random_state = (global_random_state * LCG_MULTIPLIER + LCG_INCREMENT) % LCG_MODULUS;
    return global_random_state / LCG_MODULUS;
}

export $ random_float(min_val, max_val) {
    return random() * (max_val - min_val) + min_val;
}

export $ random_int(min_val, max_val) {
    return floor(random() * (max_val - min_val + 1)) + min_val;
}

export $ random_bool() {
    return random() > 0.5;
}

export $ choice(array) {
    if (array.length == 0) {
        return null;
    }
    index = random_int(0, array.length - 1);
    return array[index];
}

export $ shuffle(array) {
    n = array.length;
    while (n > 1) {
        n = n - 1;
        k = random_int(0, n);
        temp = array[n];
        array[n] = array[k];
        array[k] = temp;
    }
    return array;
}

export $ random_array(size, min_val, max_val) {
    result = [];
    i = 0;
    while (i < size) {
        result[i] = random_float(min_val, max_val);
        i = i + 1;
    }
    return result;
}

export $ seed(new_seed) {
    global_random_state = new_seed;
}

export $ get_state() {
    return global_random_state;
}

export $ set_state(state) {
    global_random_state = state;
}

export $ random_string(length) {
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    result = "";
    i = 0;
    while (i < length) {
        result = result + chars[random_int(0, chars.length - 1)];
        i = i + 1;
    }
    return result;
}

export $ weighted_choice(items, weights) {
    if (items.length != weights.length) {
        return null;
    }
    
    total_weight = 0;
    i = 0;
    while (i < weights.length) {
        total_weight = total_weight + weights[i];
        i = i + 1;
    }
    
    r = random() * total_weight;
    cumulative = 0;
    
    j = 0;
    while (j < items.length) {
        cumulative = cumulative + weights[j];
        if (r <= cumulative) {
            return items[j];
        }
        j = j + 1;
    }
    
    return items[items.length - 1];
}