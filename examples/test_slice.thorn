// Test slice notation for arrays

// Basic array for testing
arr = [1, 2, 3, 4, 5];

// Test basic slice operations
print("Original array:");
print(arr);

// Test slice with both start and end
print("\narr[1:3] (should be [2, 3]):");
print(arr[1:3]);

// Test slice with only start
print("\narr[2:] (should be [3, 4, 5]):");
print(arr[2:]);

// Test slice with only end
print("\narr[:3] (should be [1, 2, 3]):");
print(arr[:3]);

// Test slice with no indices (copy)
print("\narr[:] (should be [1, 2, 3, 4, 5]):");
print(arr[:]);

// Test negative indices
print("\nNegative index tests:");
print("arr[-3:] (should be [3, 4, 5]):");
print(arr[-3:]);

print("\narr[1:-1] (should be [2, 3, 4]):");
print(arr[1:-1]);

print("\narr[-3:-1] (should be [3, 4]):");
print(arr[-3:-1]);

// Test edge cases
print("\nEdge cases:");
print("arr[10:] (out of bounds start, should be []):");
print(arr[10:]);

print("\narr[:10] (out of bounds end, should be [1, 2, 3, 4, 5]):");
print(arr[:10]);

print("\narr[3:1] (start > end, should be []):");
print(arr[3:1]);

// Test with empty array
empty = [];
print("\nEmpty array tests:");
print("empty[:] (should be []):");
print(empty[:]);

// Test chaining with other operations
print("\nChaining operations:");
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
print("numbers[2:8] followed by [1:4]:");
subset = numbers[2:8];  // [3, 4, 5, 6, 7, 8]
print(subset[1:4]);     // [4, 5, 6]

// Test that slice creates a copy
print("\nSlice creates a copy:");
original = [1, 2, 3];
sliced = original[1:];
sliced[0] = 99;
print("Original (should be [1, 2, 3]):");
print(original);
print("Sliced and modified (should be [99, 3]):");
print(sliced);